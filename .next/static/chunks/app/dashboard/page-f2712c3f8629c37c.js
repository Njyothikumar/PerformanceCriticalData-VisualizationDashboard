(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[702],{3553:function(e,t,n){Promise.resolve().then(n.bind(n,2756))},2756:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return O}});var a=n(7437),i=n(2265);let s=(e,t)=>{let[n,a]=(0,i.useState)([]),[s,l]=(0,i.useState)([]),[r,o]=(0,i.useState)({}),[c,d]=(0,i.useState)(!0),x=(0,i.useRef)(null);return(0,i.useEffect)(()=>{try{let n=new Blob(["\n  // Inlined from lib/dataGenerator.ts\n  const CATEGORIES = ['A', 'B', 'C', 'D', 'E'];\n  let lastId = 0;\n\n  function generateDataPoint(timestamp, prevValue) {\n    const value = prevValue !== null\n      ? Math.max(0, Math.min(100, prevValue + (Math.random() - 0.5) * 5))\n      : 50 + (Math.random() - 0.5) * 20;\n      \n    return {\n      id: ++lastId,\n      timestamp,\n      value,\n      latency: 50 + Math.random() * 450,\n      category: CATEGORIES[Math.floor(Math.random() * CATEGORIES.length)],\n    };\n  };\n\n  function generateInitialData(count, timeWindowMs) {\n    const data = [];\n    const now = Date.now();\n    const timeStep = timeWindowMs / count;\n    let lastValue = null;\n    \n    for (let i = 0; i < count; i++) {\n      const timestamp = now - timeWindowMs + i * timeStep;\n      const point = generateDataPoint(timestamp, lastValue);\n      data.push(point);\n      lastValue = point.value;\n    }\n    return data;\n  };\n\n  function generateNewDataPoint(lastPoint) {\n      const lastValue = lastPoint ? lastPoint.value : 50;\n      return generateDataPoint(Date.now(), lastValue);\n  }\n\n  // Original data.worker.ts logic\n  const DATA_GENERATION_INTERVAL = 50; // ms\n\n  const timeRangeToMs = {\n    '1m': 60 * 1000,\n    '5m': 5 * 60 * 1000,\n    '1h': 60 * 60 * 1000,\n  };\n\n  let data = [];\n  let timeRange = '1m';\n  let filters = null;\n  let intervalId = null;\n\n  // Re-create the Set for selectedCategories since it doesn't transfer well\n  function processData() {\n    if (!filters) return;\n    const selectedCategories = new Set(filters.selectedCategories);\n    const filteredData = data.filter(d =>\n      d.value >= filters.valueMin &&\n      d.value <= filters.valueMax &&\n      selectedCategories.has(d.category)\n    );\n\n    const aggregateData = filteredData.reduce((acc, point) => {\n      acc[point.category] = (acc[point.category] || 0) + 1;\n      return acc;\n    }, {});\n\n    const message = {\n      type: 'data-update',\n      payload: { data, filteredData, aggregateData }\n    };\n    postMessage(message);\n  }\n\n  function initializeAndStream() {\n    if (intervalId) clearInterval(intervalId);\n\n    postMessage({ type: 'loading', payload: true });\n\n    setTimeout(() => {\n      const windowSize = timeRangeToMs[timeRange];\n      const maxDataPoints = windowSize / DATA_GENERATION_INTERVAL;\n      data = generateInitialData(maxDataPoints, windowSize);\n\n      postMessage({ type: 'loading', payload: false });\n      processData();\n\n      intervalId = self.setInterval(() => {\n        const newDataPoint = generateNewDataPoint(data[data.length - 1]);\n        const now = newDataPoint.timestamp;\n        const windowSize = timeRangeToMs[timeRange];\n\n        let startIndex = 0;\n        for (let i = 0; i < data.length; i++) {\n          if (now - data[i].timestamp < windowSize) {\n            startIndex = i;\n            break;\n          }\n        }\n        \n        const newWindow = startIndex > 0 ? data.slice(startIndex) : data;\n        data = [...newWindow, newDataPoint];\n        processData();\n      }, DATA_GENERATION_INTERVAL);\n    }, 100);\n  }\n\n  self.onmessage = (e) => {\n    const { type, payload } = e.data;\n\n    switch (type) {\n      case 'init':\n        timeRange = payload.timeRange;\n        filters = payload.filters;\n        // The Set object does not transfer via postMessage, so we receive an empty object.\n        // We convert it back to a plain array on the main thread and rebuild it here.\n        filters.selectedCategories = new Set(filters.selectedCategories);\n        initializeAndStream();\n        break;\n      case 'set-timerange':\n        timeRange = payload;\n        initializeAndStream();\n        break;\n      case 'set-filters':\n        filters = payload;\n        filters.selectedCategories = new Set(filters.selectedCategories);\n        processData();\n        break;\n    }\n  };\n"],{type:"application/javascript"}),i=URL.createObjectURL(n);x.current=new Worker(i),x.current.onmessage=e=>{let{type:t,payload:n}=e.data;"data-update"===t?(a(n.data),l(n.filteredData),o(n.aggregateData)):"loading"===t&&d(n)};let s={...t,selectedCategories:Array.from(t.selectedCategories)};x.current.postMessage({type:"init",payload:{timeRange:e,filters:s}}),URL.revokeObjectURL(i)}catch(e){console.error("Failed to initialize data worker:",e),d(!1)}return()=>{var e;null===(e=x.current)||void 0===e||e.terminate()}},[]),(0,i.useEffect)(()=>{var t;null===(t=x.current)||void 0===t||t.postMessage({type:"set-timerange",payload:e})},[e]),(0,i.useEffect)(()=>{var e;let n={...t,selectedCategories:Array.from(t.selectedCategories)};null===(e=x.current)||void 0===e||e.postMessage({type:"set-filters",payload:n})},[t]),{data:n,filteredData:s,aggregateData:r,loading:c}},l=(0,i.createContext)(void 0),r=["A","B","C","D","E"],o=e=>{let{children:t}=e,[n,o]=(0,i.useState)("1m"),[c,d]=(0,i.useState)({valueMin:0,valueMax:100,selectedCategories:new Set(r)}),{data:x,filteredData:m,aggregateData:h,loading:u}=s(n,c),g=(0,i.useMemo)(()=>({data:x,filteredData:m,aggregateData:h,timeRange:n,setTimeRange:o,filters:c,setFilters:d,loading:u}),[x,m,h,n,c]);return(0,a.jsx)(l.Provider,{value:g,children:t})},c=()=>{let e=(0,i.useContext)(l);if(void 0===e)throw Error("useData must be used within a DataProvider");return e},d=(e,t,n)=>{let a=(0,i.useRef)(null),s="line"===t||"scatter"===t;return(0,i.useEffect)(()=>{let t=e.current;if(!t||"function"!=typeof t.transferControlToOffscreen){console.warn("OffscreenCanvas is not supported or canvas is not available.");return}try{let e=new Blob(["\n    // --- Inlined from lib/canvasUtils.ts ---\n    function drawGrid(ctx, width, height, xOffset, yOffset, xSteps, ySteps, color) {\n        ctx.save();\n        ctx.translate(xOffset, yOffset);\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 0.5;\n\n        for (let i = 1; i < xSteps; i++) {\n            const x = (i / xSteps) * width;\n            ctx.beginPath();\n            ctx.moveTo(x, 0);\n            ctx.lineTo(x, height);\n            ctx.stroke();\n        }\n\n        for (let i = 1; i < ySteps; i++) {\n            const y = (i / ySteps) * height;\n            ctx.beginPath();\n            ctx.moveTo(0, y);\n            ctx.lineTo(width, y);\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n\n    function drawTimeAxis(ctx, viewMinTimestamp, viewMaxTimestamp, width, height, padding) {\n        ctx.save();\n        ctx.font = '12px sans-serif';\n        ctx.fillStyle = '#cbd5e1'; // slate-300\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n\n        const duration = viewMaxTimestamp - viewMinTimestamp;\n        \n        const labelWidth = 80;\n        let numLabels = Math.floor(width / labelWidth);\n        numLabels = Math.min(numLabels, 10);\n        numLabels = Math.max(numLabels, 2);\n\n        if (duration > 0 && numLabels > 1) {\n            for (let i = 0; i <= numLabels; i++) {\n                const ratio = i / numLabels;\n                const timestamp = viewMinTimestamp + ratio * duration;\n                const x = padding + ratio * width;\n                \n                const timeString = new Date(timestamp).toLocaleTimeString([], {\n                    hour: '2-digit',\n                    minute: '2-digit',\n                    second: '2-digit',\n                    hour12: false\n                });\n\n                ctx.fillText(timeString, x, padding + height + 5);\n            }\n        }\n        \n        ctx.fillText(\"Time\", padding + width / 2, padding + height + 25);\n        ctx.restore();\n    }\n\n    function drawValueAxis(ctx, min, max, width, height, padding, numLabels = 5, horizontal = false, label = \"Value\") {\n        ctx.save();\n        ctx.font = '12px sans-serif';\n        ctx.fillStyle = '#cbd5e1'; // slate-300\n        const range = max - min;\n        if (range <= 0) {\n            ctx.restore();\n            return;\n        }\n\n        if (horizontal) { // Y-axis\n            ctx.textAlign = 'right';\n            ctx.textBaseline = 'middle';\n            for (let i = 0; i <= numLabels; i++) {\n                const ratio = i / numLabels;\n                const value = max - ratio * range;\n                const y = padding + ratio * height;\n                ctx.fillText(value.toFixed(0), padding - 8, y);\n            }\n            \n            ctx.translate(15, padding + height/2);\n            ctx.rotate(-Math.PI/2);\n            ctx.textAlign = 'center';\n            ctx.fillText(label, 0, 0);\n        } else { // X-axis\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'top';\n            for (let i = 0; i <= numLabels; i++) {\n                const ratio = i / numLabels;\n                const value = min + ratio * range;\n                const x = padding + ratio * width;\n                ctx.fillText(value.toFixed(0), x, padding + height + 5);\n            }\n            ctx.fillText(label, padding + width / 2, padding + height + 25);\n        }\n        \n        ctx.restore();\n    }\n    \n    // --- Color Palette ---\n    const CATEGORIES = ['A', 'B', 'C', 'D', 'E'];\n    const CATEGORY_COLORS = { A: '#14b8a6', B: '#8b5cf6', C: '#ec4899', D: '#f97316', E: '#38bdf8' };\n\n    // --- Inlined from lib/chartDrawers.ts ---\n    function drawLineChart(ctx, width, height, data, viewState) {\n        if (data.length < 2) return;\n        const padding = 40;\n        const chartWidth = width - padding * 2;\n        const chartHeight = height - padding * 2;\n\n        const fullMinTimestamp = data[0].timestamp;\n        const fullMaxTimestamp = data[data.length - 1].timestamp;\n        const fullTimeRange = fullMaxTimestamp - fullMinTimestamp;\n        const viewMinTimestamp = fullMinTimestamp + viewState.x.min * fullTimeRange;\n        const viewMaxTimestamp = fullMinTimestamp + viewState.x.max * fullTimeRange;\n        \n        const fullValueMax = 100;\n        const fullValueMin = 0;\n        const fullValueRange = fullValueMax - fullValueMin;\n        const viewValueMin = fullValueMin + viewState.y.min * fullValueRange;\n        const viewValueMax = fullValueMin + viewState.y.max * fullValueRange;\n\n        drawGrid(ctx, chartWidth, chartHeight, padding, padding, 10, 10, 'rgba(255, 255, 255, 0.1)');\n        drawTimeAxis(ctx, viewMinTimestamp, viewMaxTimestamp, chartWidth, chartHeight, padding);\n        drawValueAxis(ctx, viewValueMin, viewValueMax, chartWidth, chartHeight, padding, 5, true, \"Value\");\n        \n        ctx.save();\n        ctx.translate(padding, padding);\n        \n        const visibleData = data.filter(p => p.timestamp >= viewMinTimestamp && p.timestamp <= viewMaxTimestamp);\n        const viewTimeRange = viewMaxTimestamp - viewMinTimestamp;\n        const viewValueRange = viewValueMax - viewValueMin;\n        if (viewTimeRange <= 0 || viewValueRange <= 0) {\n            ctx.restore();\n            return;\n        };\n\n        ctx.beginPath();\n        for (let i = 0; i < visibleData.length; i++) {\n            const point = visibleData[i];\n            const x = ((point.timestamp - viewMinTimestamp) / viewTimeRange) * chartWidth;\n            const y = chartHeight - ((point.value - viewValueMin) / viewValueRange) * chartHeight;\n            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);\n        }\n        \n        ctx.strokeStyle = '#22d3ee';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        \n        ctx.restore();\n    }\n\n    function drawBarChart(ctx, width, height, data) {\n        const padding = 40;\n        const chartWidth = width - padding * 2;\n        const chartHeight = height - padding * 2;\n        const barCount = CATEGORIES.length;\n        const barWidth = chartWidth / barCount * 0.6;\n        const barSpacing = chartWidth / barCount * 0.4;\n        const maxCount = Math.max(1, ...Object.values(data));\n        drawValueAxis(ctx, 0, maxCount, chartWidth, chartHeight, padding, 5, true, 'Count');\n        \n        ctx.save();\n        ctx.translate(padding, padding);\n        \n        CATEGORIES.forEach((category, i) => {\n            const count = data[category] || 0;\n            const barHeight = (count / maxCount) * chartHeight;\n            const x = i * (barWidth + barSpacing) + barSpacing / 2;\n            const y = chartHeight - barHeight;\n            \n            ctx.fillStyle = CATEGORY_COLORS[category];\n            ctx.fillRect(x, y, barWidth, barHeight);\n\n            ctx.fillStyle = '#cbd5e1';\n            ctx.textAlign = 'center';\n            ctx.font = '12px sans-serif';\n            ctx.fillText(category, x + barWidth / 2, chartHeight + 15);\n        });\n        ctx.restore();\n    }\n\n    function drawScatterPlot(ctx, width, height, data, viewState) {\n        if (data.length === 0) return;\n        const padding = 40;\n        const chartWidth = width - padding * 2;\n        const chartHeight = height - padding * 2;\n\n        const fullLatencyMax = 500, fullLatencyMin = 0, fullLatencyRange = fullLatencyMax - fullLatencyMin;\n        const viewLatencyMin = fullLatencyMin + viewState.x.min * fullLatencyRange;\n        const viewLatencyMax = fullLatencyMin + viewState.x.max * fullLatencyRange;\n        \n        const fullValueMax = 100, fullValueMin = 0, fullValueRange = fullValueMax - fullValueMin;\n        const viewValueMin = fullValueMin + viewState.y.min * fullValueRange;\n        const viewValueMax = fullValueMin + viewState.y.max * fullValueRange;\n\n        drawGrid(ctx, chartWidth, chartHeight, padding, padding, 10, 10, 'rgba(255, 255, 255, 0.1)');\n        drawValueAxis(ctx, viewLatencyMin, viewLatencyMax, chartWidth, chartHeight, padding, 5, false, \"Latency (ms)\");\n        drawValueAxis(ctx, viewValueMin, viewValueMax, chartWidth, chartHeight, padding, 5, true, \"Value\");\n        \n        ctx.save();\n        ctx.globalAlpha = 0.7;\n        ctx.translate(padding, padding);\n\n        const viewLatencyRange = viewLatencyMax - viewLatencyMin;\n        const viewValueRange = viewValueMax - viewValueMin;\n        if (viewLatencyRange <= 0 || viewValueRange <= 0) {\n            ctx.restore();\n            return;\n        }\n\n        const visibleData = data.filter(p => p.latency >= viewLatencyMin && p.latency <= viewLatencyMax && p.value >= viewValueMin && p.value <= viewValueMax);\n        \n        ctx.fillStyle = '#38bdf8'; // sky-500\n        for (const point of visibleData) {\n            const x = ((point.latency - viewLatencyMin) / viewLatencyRange) * chartWidth;\n            const y = chartHeight - ((point.value - viewValueMin) / viewValueRange) * chartHeight;\n            ctx.beginPath();\n            ctx.arc(x, y, 3, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        ctx.restore();\n    }\n\n    const TIME_BINS = 12;\n    function drawHeatmap(ctx, width, height, data) {\n        const grid = Array(CATEGORIES.length).fill(0).map(() => Array(TIME_BINS).fill(0));\n        let maxCount = 0;\n        if (data.length > 0) {\n            const minTimestamp = data[0].timestamp;\n            const maxTimestamp = data[data.length - 1].timestamp;\n            const timeSpan = maxTimestamp - minTimestamp;\n            if (timeSpan > 0) {\n                for (const point of data) {\n                    const categoryIndex = CATEGORIES.indexOf(point.category);\n                    const timeRatio = (point.timestamp - minTimestamp) / timeSpan;\n                    const timeIndex = Math.floor(timeRatio * TIME_BINS);\n                    if (categoryIndex !== -1 && timeIndex >= 0 && timeIndex < TIME_BINS) {\n                        grid[categoryIndex][timeIndex]++;\n                        if (grid[categoryIndex][timeIndex] > maxCount) {\n                            maxCount = grid[categoryIndex][timeIndex];\n                        }\n                    }\n                }\n            }\n        }\n        if (maxCount === 0) return;\n        const padding = 40;\n        const chartWidth = width - padding * 2;\n        const chartHeight = height - padding * 2;\n        const cellWidth = chartWidth / TIME_BINS;\n        const cellHeight = chartHeight / CATEGORIES.length;\n\n        for (let i = 0; i < CATEGORIES.length; i++) {\n            for (let j = 0; j < TIME_BINS; j++) {\n                const count = grid[i][j];\n                const intensity = count / maxCount;\n                ctx.fillStyle = `rgba(6, 182, 212, ${intensity})`;\n                ctx.fillRect(padding + j * cellWidth, padding + i * cellHeight, cellWidth, cellHeight);\n            }\n        }\n        ctx.fillStyle = '#cbd5e1';\n        ctx.font = '12px sans-serif';\n        ctx.textAlign = 'right';\n        ctx.textBaseline = 'middle';\n        for (let i = 0; i < CATEGORIES.length; i++) {\n            ctx.fillText(CATEGORIES[i], padding - 15, padding + i * cellHeight + cellHeight / 2);\n        }\n        ctx.textAlign = 'center';\n        ctx.fillText(\"Time Bins\", padding + chartWidth/2, padding + chartHeight + 30);\n    }\n    \n    // --- Original render.worker.ts logic ---\n    let ctx = null;\n    let width = 0;\n    let height = 0;\n    let currentChartType = null;\n    let currentData = null;\n    let animationFrameId = null;\n\n    const chartDrawers = {\n        line: drawLineChart,\n        bar: drawBarChart,\n        scatter: drawScatterPlot,\n        heatmap: drawHeatmap,\n    };\n    \n    // --- Zoom/Pan State ---\n    const viewStates = {\n        line: { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } },\n        scatter: { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } },\n    };\n    let isPanning = false;\n    let lastPanPosition = { x: 0, y: 0 };\n\n\n    function render() {\n        if (ctx && width > 0 && height > 0) {\n            ctx.clearRect(0, 0, width, height);\n            if(currentChartType && currentData) {\n                const drawFunction = chartDrawers[currentChartType];\n                if (drawFunction) {\n                    const viewState = viewStates[currentChartType];\n                    drawFunction(ctx, width, height, currentData, viewState);\n                }\n            }\n        }\n        animationFrameId = self.requestAnimationFrame(render);\n    }\n\n    self.onmessage = (e) => {\n        const { type, payload } = e.data;\n\n        switch (type) {\n            case 'init':\n                const canvas = payload.canvas;\n                ctx = canvas.getContext('2d');\n                width = payload.width;\n                height = payload.height;\n                canvas.width = width * payload.dpr;\n                canvas.height = height * payload.dpr;\n                ctx.scale(payload.dpr, payload.dpr);\n                if (animationFrameId === null) {\n                    render();\n                }\n                break;\n            case 'resize':\n                width = payload.width;\n                height = payload.height;\n                if (ctx?.canvas) {\n                    ctx.canvas.width = width * payload.dpr;\n                    ctx.canvas.height = height * payload.dpr;\n                    ctx.scale(payload.dpr, payload.dpr);\n                }\n                break;\n            case 'render':\n                currentChartType = payload.chartType;\n                currentData = payload.data;\n                break;\n            case 'pan-start':\n                isPanning = true;\n                lastPanPosition = payload;\n                break;\n            case 'pan-move': {\n                if (!isPanning) break;\n                const vs = viewStates[currentChartType];\n                if (!vs) break;\n\n                const dx = payload.x - lastPanPosition.x;\n                const dy = payload.y - lastPanPosition.y;\n                lastPanPosition = payload;\n                \n                const xRange = vs.x.max - vs.x.min;\n                const yRange = vs.y.max - vs.y.min;\n\n                const xDelta = (dx / width) * xRange;\n                const yDelta = (dy / height) * yRange;\n\n                vs.x.min = Math.max(0, vs.x.min - xDelta);\n                vs.x.max = vs.x.min + xRange;\n                if (vs.x.max > 1) {\n                    vs.x.max = 1;\n                    vs.x.min = vs.x.max - xRange;\n                }\n\n                vs.y.min = Math.max(0, vs.y.min + yDelta);\n                vs.y.max = vs.y.min + yRange;\n                if (vs.y.max > 1) {\n                    vs.y.max = 1;\n                    vs.y.min = vs.y.max - yRange;\n                }\n                break;\n            }\n            case 'pan-end':\n                isPanning = false;\n                break;\n            case 'zoom': {\n                const vs = viewStates[currentChartType];\n                if (!vs) break;\n                const { x, y, delta } = payload;\n                const zoomFactor = delta < 0 ? 1.1 : 0.9;\n                \n                const padding = 40;\n                const chartWidth = width - padding * 2;\n                const chartHeight = height - padding * 2;\n                if (x < padding || x > width - padding || y < padding || y > height - padding) break;\n\n                const xMouseRatio = (x - padding) / chartWidth;\n                const yMouseRatio = 1 - ((y - padding) / chartHeight);\n\n                const xRange = vs.x.max - vs.x.min;\n                const newXRange = Math.max(0.01, xRange * zoomFactor);\n                const xRangeDelta = newXRange - xRange;\n                vs.x.min = Math.max(0, vs.x.min - xRangeDelta * xMouseRatio);\n                vs.x.max = Math.min(1, vs.x.min + newXRange);\n                if (vs.x.max - vs.x.min < newXRange) { // Adjust if clamped\n                  vs.x.min = vs.x.max - newXRange;\n                }\n\n\n                const yRange = vs.y.max - vs.y.min;\n                const newYRange = Math.max(0.01, yRange * zoomFactor);\n                const yRangeDelta = newYRange - yRange;\n                vs.y.min = Math.max(0, vs.y.min - yRangeDelta * yMouseRatio);\n                vs.y.max = Math.min(1, vs.y.min + newYRange);\n                if (vs.y.max - vs.y.min < newYRange) {\n                   vs.y.min = vs.y.max - newYRange;\n                }\n                break;\n            }\n            case 'reset-zoom':\n                const chartToReset = payload.chartType;\n                if (viewStates[chartToReset]) {\n                    viewStates[chartToReset] = { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n                }\n                break;\n        }\n    };\n"],{type:"application/javascript"}),n=URL.createObjectURL(e);a.current=new Worker(n);let i=t.transferControlToOffscreen(),l=window.devicePixelRatio||1,{width:r,height:o}=t.getBoundingClientRect();a.current.postMessage({type:"init",payload:{canvas:i,width:r,height:o,dpr:l}},[i]);let c=new ResizeObserver(e=>{var t;if(!e||0===e.length)return;let{width:n,height:i}=e[0].contentRect;null===(t=a.current)||void 0===t||t.postMessage({type:"resize",payload:{width:n,height:i,dpr:l}})});c.observe(t);let d=e=>{var t;e.target instanceof HTMLElement&&(e.target.style.cursor="grabbing"),null===(t=a.current)||void 0===t||t.postMessage({type:"pan-start",payload:{x:e.offsetX,y:e.offsetY}})},x=e=>{var t;1===e.buttons&&(null===(t=a.current)||void 0===t||t.postMessage({type:"pan-move",payload:{x:e.offsetX,y:e.offsetY}}))},m=e=>{var t;e.target instanceof HTMLElement&&(e.target.style.cursor="grab"),null===(t=a.current)||void 0===t||t.postMessage({type:"pan-end"})},h=e=>{var t;e.target instanceof HTMLElement&&(e.target.style.cursor="grab"),null===(t=a.current)||void 0===t||t.postMessage({type:"pan-end"})},u=e=>{var t;e.preventDefault(),null===(t=a.current)||void 0===t||t.postMessage({type:"zoom",payload:{x:e.offsetX,y:e.offsetY,delta:e.deltaY}})};return s&&(t.style.cursor="grab",t.addEventListener("mousedown",d),t.addEventListener("mousemove",x),t.addEventListener("mouseup",m),t.addEventListener("mouseleave",h),t.addEventListener("wheel",u,{passive:!1})),URL.revokeObjectURL(n),()=>{var e;c.disconnect(),s&&(t.style.cursor="default",t.removeEventListener("mousedown",d),t.removeEventListener("mousemove",x),t.removeEventListener("mouseup",m),t.removeEventListener("mouseleave",h),t.removeEventListener("wheel",u)),null===(e=a.current)||void 0===e||e.terminate()}}catch(e){console.error("Failed to initialize render worker:",e)}},[e,s]),(0,i.useEffect)(()=>{var e;null===(e=a.current)||void 0===e||e.postMessage({type:"render",payload:{chartType:t,data:n}})},[t,n]),{resetZoom:(0,i.useCallback)(()=>{var e;null===(e=a.current)||void 0===e||e.postMessage({type:"reset-zoom",payload:{chartType:t}})},[t])}};var x=i.memo(()=>{let{filteredData:e}=c(),t=(0,i.useRef)(null),{resetZoom:n}=d(t,"line",e);return(0,a.jsxs)("div",{className:"relative w-full h-full group",children:[(0,a.jsx)("canvas",{ref:t,className:"w-full h-full"}),(0,a.jsx)("button",{onClick:n,className:"absolute top-2 right-2 px-2 py-1 text-xs bg-gray-600/70 text-gray-300 rounded opacity-0 group-hover:opacity-100 transition-opacity focus:opacity-100 outline-none ring-2 ring-transparent focus:ring-cyan-500","aria-label":"Reset Zoom",children:"Reset"})]})}),m=i.memo(()=>{let{aggregateData:e}=c(),t=(0,i.useRef)(null);return d(t,"bar",e),(0,a.jsx)("canvas",{ref:t,className:"w-full h-full"})}),h=i.memo(()=>{let{filteredData:e}=c(),t=(0,i.useRef)(null),{resetZoom:n}=d(t,"scatter",e);return(0,a.jsxs)("div",{className:"relative w-full h-full group",children:[(0,a.jsx)("canvas",{ref:t,className:"w-full h-full"}),(0,a.jsx)("button",{onClick:n,className:"absolute top-2 right-2 px-2 py-1 text-xs bg-gray-600/70 text-gray-300 rounded opacity-0 group-hover:opacity-100 transition-opacity focus:opacity-100 outline-none ring-2 ring-transparent focus:ring-cyan-500","aria-label":"Reset Zoom",children:"Reset"})]})}),u=i.memo(()=>{let{filteredData:e}=c(),t=(0,i.useRef)(null);return d(t,"heatmap",e),(0,a.jsx)("canvas",{ref:t,className:"w-full h-full"})});let g=["A","B","C","D","E"];var p=i.memo(()=>{let{filters:e,setFilters:t}=c(),n=(0,i.useCallback)(e=>{t(t=>{let n=new Set(t.selectedCategories);return n.has(e)?n.delete(e):n.add(e),{...t,selectedCategories:n}})},[t]),s=(0,i.useCallback)(e=>{let{name:n,value:a}=e.target,i=Number(a);t(e=>{let t={...e,[n]:i};return"valueMin"===n&&i>t.valueMax&&(t.valueMax=i),"valueMax"===n&&i<t.valueMin&&(t.valueMin=i),t})},[t]);return(0,a.jsxs)("div",{className:"space-y-4",children:[(0,a.jsx)("h3",{className:"text-lg font-semibold text-slate-300",children:"Filters"}),(0,a.jsxs)("div",{children:[(0,a.jsxs)("label",{htmlFor:"valueMin",className:"block text-sm font-medium text-slate-400",children:["Value Range: ",e.valueMin," - ",e.valueMax]}),(0,a.jsxs)("div",{className:"mt-2 flex flex-col gap-4 pt-2",children:[(0,a.jsx)("input",{type:"range",id:"valueMin",name:"valueMin",min:"0",max:"100",value:e.valueMin,onChange:s,className:"w-full","aria-label":"Minimum Value"}),(0,a.jsx)("input",{type:"range",id:"valueMax",name:"valueMax",min:"0",max:"100",value:e.valueMax,onChange:s,className:"w-full","aria-label":"Maximum Value"})]})]}),(0,a.jsxs)("div",{children:[(0,a.jsx)("label",{className:"block text-sm font-medium text-slate-400",children:"Categories"}),(0,a.jsx)("div",{className:"mt-2 grid grid-cols-3 gap-2",children:g.map(t=>(0,a.jsx)("button",{onClick:()=>n(t),className:"px-3 py-1 text-sm rounded-md transition-all duration-200 font-medium focus:outline-none ring-2 ring-transparent focus:ring-cyan-500 ".concat(e.selectedCategories.has(t)?"bg-cyan-500 text-white":"bg-slate-700 hover:bg-slate-600 text-slate-300"),children:t},t))})]})]})});let v=[{value:"1m",label:"Last 1 Minute"},{value:"5m",label:"Last 5 Minutes"},{value:"1h",label:"Last 1 Hour"}];var f=i.memo(()=>{let{timeRange:e,setTimeRange:t,loading:n}=c(),s=(0,i.useCallback)(e=>{t(e.target.value)},[t]);return(0,a.jsxs)("div",{className:"w-full",children:[(0,a.jsx)("label",{htmlFor:"time-range-selector",className:"sr-only",children:"Time Range"}),(0,a.jsxs)("div",{className:"relative",children:[(0,a.jsx)("select",{id:"time-range-selector",value:e,onChange:s,disabled:n,className:"w-full bg-slate-700/50 border border-white/10 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500 appearance-none",children:v.map(e=>(0,a.jsx)("option",{value:e.value,children:e.label},e.value))}),(0,a.jsx)("div",{className:"pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-400",children:(0,a.jsx)("svg",{className:"fill-current h-4 w-4",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",children:(0,a.jsx)("path",{d:"M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"})})})]}),n&&(0,a.jsx)("p",{className:"text-sm text-yellow-500 mt-1 absolute",children:"Loading..."})]})});let w=e=>{let{itemHeight:t,containerHeight:n,itemCount:a,scrollTop:s,overscan:l=5}=e,{startIndex:r,endIndex:o,virtualItems:c,totalHeight:d}=(0,i.useMemo)(()=>{let e=a*t,i=Math.floor(s/t),r=Math.ceil((s+n)/t);i=Math.max(0,i-l),r=Math.min(a-1,r+l);let o=[];for(let e=i;e<=r;e++)o.push({index:e,style:{position:"absolute",top:e*t,left:0,width:"100%",height:t}});return{startIndex:i,endIndex:r,virtualItems:o,totalHeight:e}},[t,n,a,s,l]);return{startIndex:r,endIndex:o,virtualItems:c,totalHeight:d}},y={A:"bg-teal-500/20 text-teal-300 border-teal-500/30",B:"bg-purple-500/20 text-purple-300 border-purple-500/30",C:"bg-pink-500/20 text-pink-300 border-pink-500/30",D:"bg-orange-500/20 text-orange-300 border-orange-500/30",E:"bg-sky-500/20 text-sky-300 border-sky-500/30"},M=()=>(0,a.jsxs)("div",{className:"grid grid-cols-data-table gap-4 px-4 sticky top-0 z-10 bg-slate-800/80 backdrop-blur-lg text-xs text-cyan-400 uppercase font-semibold h-10 items-center border-b border-white/10",children:[(0,a.jsx)("div",{className:"text-right",children:"ID"}),(0,a.jsx)("div",{className:"text-left",children:"Timestamp"}),(0,a.jsx)("div",{className:"text-right",children:"Value"}),(0,a.jsx)("div",{className:"text-right",children:"Latency (ms)"}),(0,a.jsx)("div",{className:"text-center",children:"Category"})]}),b=i.memo(e=>{let{item:t,style:n}=e;return(0,a.jsxs)("div",{className:"grid grid-cols-data-table gap-4 px-4 items-center border-b border-white/5 hover:bg-white/10 transition-colors duration-150",style:n,children:[(0,a.jsx)("div",{className:"font-medium text-slate-300 whitespace-nowrap text-right",children:t.id}),(0,a.jsxs)("div",{className:"whitespace-nowrap text-slate-400",children:[new Date(t.timestamp).toLocaleTimeString([],{hour:"2-digit",minute:"2-digit",second:"2-digit",hour12:!1}),".",String(t.timestamp%1e3).padStart(3,"0")]}),(0,a.jsx)("div",{className:"text-right text-slate-300",children:t.value.toFixed(2)}),(0,a.jsx)("div",{className:"text-right text-slate-300",children:t.latency.toFixed(2)}),(0,a.jsx)("div",{className:"text-center flex justify-center items-center",children:(0,a.jsx)("span",{className:"px-2 py-0.5 text-xs font-medium rounded-full border ".concat(y[t.category]),children:t.category})})]})});var j=()=>{let{filteredData:e}=c(),t=(0,i.useRef)(null),[n,s]=(0,i.useState)(0),[l,r]=(0,i.useState)(0);(0,i.useEffect)(()=>{let e=t.current;if(!e)return;let n=new ResizeObserver(()=>{r(e.clientHeight)});return n.observe(e),r(e.clientHeight),()=>n.disconnect()},[]);let{virtualItems:o,totalHeight:d}=w({itemCount:e.length,containerHeight:l,itemHeight:36,scrollTop:n});return(0,a.jsxs)("div",{ref:t,onScroll:e=>{s(e.currentTarget.scrollTop)},className:"h-full w-full overflow-y-auto rounded text-sm",children:[(0,a.jsx)(M,{}),(0,a.jsx)("div",{style:{height:d,position:"relative"},children:o.map(t=>{let{index:n,style:i}=t,s=e[n];return s?(0,a.jsx)(b,{item:s,style:i},s.id):null})})]})};let R=()=>{let[e,t]=(0,i.useState)(0),[n,a]=(0,i.useState)(0),s=(0,i.useRef)(performance.now()),l=(0,i.useRef)(0),r=(0,i.useRef)(null);return(0,i.useEffect)(()=>{let e=n=>{l.current++;let i=n-s.current;i>=1e3&&(t(1e3*l.current/i),performance.memory&&a(performance.memory.usedJSHeapSize/1048576),s.current=n,l.current=0),r.current=requestAnimationFrame(e)};return r.current=requestAnimationFrame(e),()=>{r.current&&cancelAnimationFrame(r.current)}},[]),{fps:e,memoryUsage:n}},T=e=>{let{children:t}=e;return(0,a.jsx)("div",{className:"text-slate-400 w-5 h-5",children:t})},S=()=>(0,a.jsx)(T,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M8.25 21v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21m0 0h4.5V3.545M12.75 21h7.5V10.75M2.25 21h1.5m18 0h-18M2.25 9l4.5-1.636M18.75 3l-1.5.545m0 6.205l3 1m1.5.5l-1.5-.5M3 7.5l3 1.5M3 7.5l-1.5-1.5m1.5 1.5l-1.5 1.5m16.5-3l1.5 1.5m-1.5-1.5l1.5-1.5M12 9.75l-1.5-1.5M15 12l-3-3m0 0l-3 3m3-3v12"})})}),C=()=>(0,a.jsx)(T,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M8.25 3v1.5M4.5 8.25H3m18 0h-1.5M4.5 12H3m18 0h-1.5m-15 3.75H3m18 0h-1.5M8.25 19.5V21M12 3v1.5m0 15V21m3.75-18v1.5m0 15V21m-9-1.5h10.5a2.25 2.25 0 002.25-2.25V6.75a2.25 2.25 0 00-2.25-2.25H6.75A2.25 2.25 0 004.5 6.75v10.5a2.25 2.25 0 002.25 2.25z"})})});var k=i.memo(()=>{let{fps:e,memoryUsage:t}=R();return(0,a.jsxs)("div",{className:"glass-card flex items-center gap-4 px-3 py-2 text-sm",children:[(0,a.jsxs)("div",{className:"flex items-center gap-2",children:[(0,a.jsx)(S,{}),(0,a.jsxs)("div",{className:"flex items-baseline gap-1.5",children:[(0,a.jsx)("span",{className:"font-bold text-green-400 w-[2ch] text-right",children:e.toFixed(0)}),(0,a.jsx)("span",{className:"text-xs text-slate-400",children:"FPS"})]})]}),(0,a.jsx)("div",{className:"border-l border-white/10 h-5"}),(0,a.jsxs)("div",{className:"flex items-center gap-2",children:[(0,a.jsx)(C,{}),(0,a.jsxs)("div",{className:"flex items-baseline gap-1.5",children:[(0,a.jsx)("span",{className:"font-bold text-sky-400 w-[4ch] text-right",children:t.toFixed(1)}),(0,a.jsx)("span",{className:"text-xs text-slate-400",children:"MB"})]})]})]})});let L=e=>{let{children:t}=e;return(0,a.jsx)("div",{className:"text-cyan-400 w-6 h-6 flex-shrink-0",children:t})},N=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6a2.25 2.25 0 01-2.25-2.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6a2.25 2.25 0 012.25-2.25H18A2.25 2.25 0 0120.25 6v2.25A2.25 2.25 0 0118 10.5h-2.25a2.25 2.25 0 01-2.25-2.25V6zM13.5 15.75a2.25 2.25 0 012.25-2.25H18a2.25 2.25 0 012.25 2.25V18A2.25 2.25 0 0118 20.25h-2.25A2.25 2.25 0 0113.5 18v-2.25z"})})}),V=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M2.25 18L9 11.25l4.306 4.307a11.95 11.95 0 015.814-5.519l2.74-1.22m0 0l-5.94-2.28m5.94 2.28l-2.28 5.941"})})}),E=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3.375 19.5h17.25m-17.25 0a1.125 1.125 0 01-1.125-1.125M3.375 19.5v-1.5M3.375 19.5h1.5v-1.5M3.375 19.5v-1.5m1.5 1.5v-1.5m14.25-15v1.5m1.5-1.5v1.5m-1.5-1.5h-1.5v1.5M19.5 4.5v1.5m-1.5-1.5v1.5m-14.25 0v15m17.25-15v15M4.875 4.5h14.25M4.875 4.5a1.125 1.125 0 01-1.125-1.125M4.875 4.5v-1.5m-1.5 1.5v-1.5m1.5 1.5h-1.5v-1.5M4.875 19.5v-15m14.25 15v-15"})})}),A=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.568a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z"})})}),I=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15.042 21.672L13.684 16.6m0 0l-2.51 2.225.569-9.47 5.227 7.917-3.286-.672zm-7.518-.267A8.25 8.25 0 1120.25 10.5M8.288 14.212A5.25 5.25 0 1117.25 10.5"})})}),D=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z"})})}),W=()=>(0,a.jsx)(L,{children:(0,a.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:(0,a.jsx)("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 4.5v15m6-15v15m-10.875 0h15.75c.621 0 1.125-.504 1.125-1.125V5.625c0-.621-.504-1.125-1.125-1.125H4.125C3.504 4.5 3 5.004 3 5.625v12.75c0 .621.504 1.125 1.125 1.125z"})})}),H=()=>(0,a.jsxs)("header",{className:"flex flex-col md:flex-row justify-between items-start md:items-center gap-4",children:[(0,a.jsxs)("div",{className:"flex items-center gap-3",children:[(0,a.jsx)(N,{}),(0,a.jsxs)("div",{children:[(0,a.jsx)("h1",{className:"text-4xl font-bold bg-gradient-to-r from-cyan-400 to-sky-500 bg-clip-text text-transparent",children:"Real-Time Dashboard"}),(0,a.jsx)("p",{className:"text-slate-400 mt-1",children:"Visualizing 10,000+ data points at 60fps."})]})]}),(0,a.jsxs)("div",{className:"flex items-center gap-4 w-full md:w-auto",children:[(0,a.jsx)("div",{className:"flex-1",children:(0,a.jsx)(f,{})}),(0,a.jsx)(k,{})]})]}),P=e=>{let{title:t,children:n,className:i="",icon:s}=e;return(0,a.jsxs)("div",{className:"glass-card p-4 flex flex-col ".concat(i),children:[(0,a.jsxs)("div",{className:"flex items-center gap-2 mb-2 flex-shrink-0",children:[s,(0,a.jsx)("h3",{className:"text-lg font-semibold text-cyan-400",children:t})]}),(0,a.jsx)("div",{className:"flex-1 relative min-h-0",children:n})]})};var O=()=>((0,i.useEffect)(()=>{"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js",{scope:"/"}).then(e=>{console.log("Service Worker registered with scope:",e.scope)}).catch(e=>{console.error("Service Worker registration failed: ",e)})})},[]),(0,a.jsx)(o,{children:(0,a.jsxs)("div",{className:"min-h-screen bg-slate-900 text-slate-300 p-4 lg:p-6 font-sans flex flex-col",children:[(0,a.jsx)(H,{}),(0,a.jsxs)("main",{className:"flex-1 grid grid-cols-1 lg:grid-cols-3 gap-6 mt-6",children:[(0,a.jsxs)("div",{className:"lg:col-span-2 flex flex-col gap-6",children:[(0,a.jsx)(P,{title:"Value over Time",icon:(0,a.jsx)(V,{}),className:"h-[40vh] min-h-[300px]",children:(0,a.jsx)(x,{})}),(0,a.jsx)(P,{title:"Real-Time Data Table (Virtualized)",icon:(0,a.jsx)(E,{}),className:"h-[45vh] min-h-[300px]",children:(0,a.jsx)(j,{})})]}),(0,a.jsxs)("div",{className:"lg:col-span-1 flex flex-col gap-6",children:[(0,a.jsx)(P,{title:"Controls",icon:(0,a.jsx)(A,{}),children:(0,a.jsx)(p,{})}),(0,a.jsx)(P,{title:"Value vs. Latency",icon:(0,a.jsx)(I,{}),className:"h-[300px]",children:(0,a.jsx)(h,{})}),(0,a.jsx)(P,{title:"Category Distribution",icon:(0,a.jsx)(D,{}),className:"h-[300px]",children:(0,a.jsx)(m,{})}),(0,a.jsx)(P,{title:"Event Frequency",icon:(0,a.jsx)(W,{}),className:"h-[300px]",children:(0,a.jsx)(u,{})})]})]})]})}))}},function(e){e.O(0,[971,23,744],function(){return e(e.s=3553)}),_N_E=e.O()}]);